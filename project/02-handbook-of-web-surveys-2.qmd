---
title: "Simulation studies for mis-classification in non-probability surveys"
author: "Maciej BerÄ™sewicz"
editor: source
format: 
  html:
    self-contained: true
    toc: true
    number_sections: true
---

## Basic setup

Read the packages for the simulation studies

```{r setup, message=FALSE, warning=FALSE}
library(simex) ## only confusion matrix is provided
library(nonprobsvy)
library(data.table)
library(vcd)
library(VIM)
library(ggplot2)
library(knitr)
source("../codes/functions.R")
```

## Simulation study

I use a modified simulation study from the section 10.3 from **Biffignandi, S., & Bethlehem, J. (2021). Handbook of web surveys. John Wiley & Sons**. (second edition).

A fictitious population of 300,000 individuals was constructed. There were five variables:

-   **Age** in three categories:

    -   Young (with probability 0.40),
    -   Middle-aged (with probability 0.35), and
    -   Old (with probability 0.25).

-   **Ethnic origin** in two categories:

    -   Native (with probability 0.85) and
    -   Nonnative (with probability 0.15).

-   **Having access to Internet** with two categories: Yes and No according to the following table

|            |             | Yes  | No   |
|------------|-------------|------|------|
| Native     | Young       | 0.90 | 0.10 |
|            | Middle-aged | 0.70 | 0.30 |
|            | Old         | 0.50 | 0.50 |
| Non-native | Young       | 0.25 | 0.75 |
|            | Middle-aged | 0.15 | 0.85 |
|            | Old         | 0.10 | 0.90 |

-   **Voted for the National Elderly Party** (NEP). The probability to vote for this party depended on age only:
    -   Probabilities were 0.05 (for Young),
    -   0.40 (for Middle-aged), and
    -   0.60 (for Old).
-   **Voted for the New Internet Party** (NIP). The probability to vote for this party depended on both age and having Internet. For people with Internet access, the probabilities were 0.80 (for Young), 0.40 (for Middle-aged), and 0.20 (for Old). For people without Internet access, all probabilities were equal to 0.10 . So, for people with Internet voting decreased with age. The voting probability was low for people without Internet.

|             |             | Yes  | No   |
|-------------|-------------|------|------|
| Internet    | Young       | 0.80 | 0.20 |
|             | Middle-aged | 0.40 | 0.20 |
|             | Old         | 0.20 | 0.80 |
| No internet | Young       | 0.10 | 0.90 |
|             | Middle-aged | 0.10 | 0.90 |
|             | Old         | 0.10 | 0.90 |

Codes to generate population data

```{r}
set.seed(2024)
N <- 100000
pop_data <- data.table(age = sample(c("Young", "Middle-aged", "Old"), size = N, c(0.40, 0.35, 0.25), replace = T),
                       ethnic = sample(c("Native", "Nonnative"), size = N, prob = c(0.85, 0.15), replace = T))

pop_data[ethnic == "Native" & age == "Young", internet := rbinom(.N, 1, 0.90)]
pop_data[ethnic == "Native" & age == "Middle-aged", internet := rbinom(.N, 1, 0.70)]
pop_data[ethnic == "Native" & age == "Old", internet := rbinom(.N, 1, 0.50)]

pop_data[ethnic == "Nonnative" & age == "Young", internet := rbinom(.N, 1, 0.25)]
pop_data[ethnic == "Nonnative" & age == "Middle-aged", internet := rbinom(.N, 1, 0.15)]
pop_data[ethnic == "Nonnative" & age == "Old", internet := rbinom(.N, 1, 0.10)]

pop_data[age == "Young", NEP := rbinom(.N, 1, 0.05)]
pop_data[age == "Middle-aged", NEP := rbinom(.N, 1, 0.40)]
pop_data[age == "Old", NEP := rbinom(.N, 1, 0.60)]

pop_data[age == "Young" & internet == 1, NIP := rbinom(.N, 1, 0.80)]
pop_data[age == "Middle-aged" & internet == 1, NIP := rbinom(.N, 1, 0.40)]
pop_data[age == "Old" & internet == 1, NIP := rbinom(.N, 1, 0.20)]
pop_data[internet == 0, NIP := rbinom(.N, 1, 0.10)]

pop_data[, age := factor(age, levels = c("Young", "Middle-aged", "Old"))]
pop_data[, ethnic := factor(ethnic, levels = c("Native", "Nonnative"))]
pop_data[, pi_A := exp(-2 + 2*internet) / (1 + exp(-2 + 2*internet))]
```

## Definition of mis-classification matrices

For ethnicity, the mis-classification matrix is defined as follows:

$$
\Gamma_{ethnic} = \begin{bmatrix}
0.7 & 0.05 \\
0.3 & 0.95
\end{bmatrix}
$$ where rows correspond to mis-classified levels (1 row = native, 2 row= non-native). This mean that original native people are classified as native with probability 0.70 and as non-native with probability 0.30.

The matrix for age is given below.

$$
\Gamma_{age} = \begin{bmatrix}
0.85 & 0.20 & 0.05 \\
0.15 & 0.70 & 0.15 \\
0.05 & 0.10 & 0.80
\end{bmatrix}
$$

This means that original young people are classified as young with probability 0.85, as middle-aged with probability 0.15, and as old with probability 0.05.

Codes to create matrix

```{r}
gamma_ethnic <- matrix(c(0.7, 0.3, 0.05, 0.95), ncol = 2)
gamma_age <- matrix(c(0.85, 0.15, 0.05, 
                      0.20, 0.70, 0.10, 
                      0.05, 0.15, 0.80), ncol = 3)

colnames(gamma_age) <- levels(pop_data$age)
colnames(gamma_ethnic) <- levels(pop_data$ethnic)
```

Here, I create the matrix of new variables age\* and ethnic\* based on sampling from a given matrix.

```{r}
set.seed(2024) 
dd <- simex::misclass(pop_data[, .(age, ethnic)], 
                      list(age = gamma_age, ethnic = gamma_ethnic),
                      k = 1)
pop_data[, age_m := dd$age]
pop_data[, ethnic_m := dd$ethnic]
```

The empirical classification based on this matrix is as follows

```{r}
xtabs(~age_m + age, data = pop_data) |> prop.table(2) |> knitr::kable()
xtabs(~ethnic_m + ethnic, data = pop_data) |> prop.table(2)  |> knitr::kable()
```

## How mis-classification changes dependence with NEP?

I measure the relationship between NEP given covariates and NEP given mis-classified covariates. I use Cramer's V as a measure of association.

1.  NEP and age / NEP and age\*

```{r}
c(original = assocstats(xtabs(~NEP + age, data = pop_data))$cramer, 
  with_error = assocstats(xtabs(~NEP + age_m, data = pop_data))$cramer) |> knitr::kable()
```

2.  NEP and ethnicity and NEP and ethnicity\*

```{r}
c(original = assocstats(xtabs(~NEP + ethnic, data = pop_data))$cramer, 
  with_error = assocstats(xtabs(~NEP + ethnic_m, data = pop_data))$cramer)  |> knitr::kable()
```

3.  age and ethnicity / age\* and ethnicity\*

```{r}
c(original = assocstats(xtabs(~age + ethnic, data = pop_data))$cramer, 
  with_error = assocstats(xtabs(~age_m + ethnic_m, data = pop_data))$cramer)  |> knitr::kable()
```

Summary:

-   mis-classification decrease the strength of the relationship
-   NEP and ethnicity is not correlated
-   age and ethnicity are independent (as defined, this may be changed)

## Details regarding the simulation study

### Selection mechanisms

We consider the following selection mechanism of non-probability and probability sample

-   selection to non-probability sample ($S_A$, $E(n_A/B)\approx 0.36$, i.e. $n_a\approx 11,000$)):

$$
P(k \in S_A) = \frac{\exp(-2 + 2\times \text{Internet})}{1+ \exp(-2 + 2\times \text{Internet})}
$$

-- selection to probability sample ($S_B$): simple random sampling of size $n_B = 1000$

-- for measuring the mis-classification w we assume a stratified random sampling from $S_A$ where each level of mis-classified variables is represented by 100 observations (in total represents 600 observations).

### Estimation

The goal is to estimate share of people voting for NEP (we do not consider NIP yet). We consider the following estimators:

+ sample mean based on probability sample $S_B$ -- `nep_srs`
+ naive - sample mean based on $S_A$ -- `nep_naive`

We consider the following mass imputation estimators:

+ based on variables measured without error -- `mi_cor`
+ based on variables measured with error -- `mi_err`
+ based on variables measured with error and corrected by MC-SIMEX approach -- `mi_li`, `mi_qu`, `mi_ll`
+ based on variables measured with error where true values of age and ethnic are imputed using random forest -- `mi_imp`

We report:

+ bias, 
+ variance,
+ rmse,
+ empirical coverage rate of 95% confidence interval

### Code for simulation study


```{r cache = TRUE}
set.seed(123)
n_sims <- 100 ## number of simulations
n_B <- 1000 
n_valid <- 100 ## size of validation sample
stratified <- TRUE
B_simex <- 50
results  <- list() 

for (r in 1:n_sims) {
  
  if (r %% 10 == 0) print(r)
  
  S_A <- copy(pop_data[rbinom(.N, 1, pi_A) == 1])
  S_A[, id:=1:.N]
  
  S_B <- copy(pop_data[sample(1:.N, n_B)])
  S_B[, weights := N/n_B]
  S_B_svy <- svydesign(ids = ~1, data = S_B, weights = ~weights)
  
  est_sb <- svymean(~NEP + NIP, design = S_B_svy)
  est_sa_naive <- colMeans(S_A[, .(NEP, NIP)])
  
  est_sa_mi <- nonprob(
    outcome = NEP + NIP ~ age + ethnic,
    data = S_A,
    svydesign = S_B_svy,
    method_outcome = "glm",
    family_outcome = "binomial"
  )
  
  ## with errors (estimated from S_A only)
  S_A_err <- copy(S_A)

  if (stratified) {
    S_A_err[, w:=.N/n_valid, .(age_m, ethnic_m)]
    S_A_err_valid_sample <- copy(S_A_err[,.SD[sample(.N, n_valid)], by = .(age_m, ethnic_m)])  
  } else {
    S_A_err[, w:=.N/(n_valid*6)]
    S_A_err_valid_sample <- copy(S_A_err[sample(1:.N, n_valid*6)])
  }
  
  sampled_ids <- S_A_err_valid_sample$id
  error_age <- as.matrix(prop.table(xtabs(w~ age_m + age, data = S_A_err_valid_sample), margin = 2))
  error_eth <- as.matrix(prop.table(xtabs(w~ ethnic_m + ethnic, data = S_A_err_valid_sample), margin = 2))
  S_A_err[, age := NULL]
  S_A_err[, ethnic := NULL]
  S_A_err[, age := age_m]
  S_A_err[, ethnic := ethnic_m]
  
  est_sa_mi_errors <- nonprob(
    outcome = NEP + NIP ~ age + ethnic,
    data = S_A_err,
    svydesign = S_B_svy,
    method_outcome = "glm",
    family_outcome = "binomial"
  )

  est_sa_mi_err <- glm(NEP ~ age + ethnic, family = binomial, x = TRUE, y = TRUE,
                       data = S_A_err)
  
  ## model parameters corrected by MC-SIMEX approach
  res_mi_li <- tryCatch(simex::mcsimex(model = est_sa_mi_err,
                              mc.matrix = list(age = error_age, ethnic = error_eth),
                              SIMEXvariable = c("age", "ethnic"),
                              fitting.method	= "linear",
                              asymptotic = FALSE,
                              jackknife.estimation	= FALSE,
                              B = B_simex), error = function(e) NULL)
   
  if (is.null(res_mi_li)) next
  
  res_mi_qu <- refit(object = res_mi_li,
                     fitting.method = "quadratic",
                     asymptotic = FALSE,
                     jackknife.estimation	= FALSE)
   
  res_mi_ll <- refit(object = res_mi_qu,
                     fitting.method = "loglinear",
                     asymptotic = FALSE,
                     jackknife.estimation	= FALSE)
  
  
  
  S_B_svy <- update(S_B_svy, 
         NEP_li = predict(res_mi_li, S_B_svy$variables, type = "response"),
         NEP_qu = predict(res_mi_qu, S_B_svy$variables, type = "response"),
         NEP_ll = predict(res_mi_ll, S_B_svy$variables, type = "response"))
  
  res <- svymean(~NEP_li + NEP_qu + NEP_ll, design = S_B_svy)
  res_ci <- confint(res)
  
  ## assume that we sample subsample and have only partial information
  S_A_imputation <- copy(S_A)
  S_A_imputation[!id %in% sampled_ids, ":="(age = NA, ethnic = NA)]
  
  S_A_imputation_kk <- rangerImpute(formula = age + ethnic ~ age_m + ethnic_m ,
                                    data = S_A_imputation)
  
  S_A_imputation[, age:= S_A_imputation_kk$age]
  S_A_imputation[, ethnic:= S_A_imputation_kk$ethnic]
  
  est_sa_mi_imp <- nonprob(
    outcome = NEP + NIP ~ age + ethnic,
    data = S_A_imputation,
    svydesign = S_B_svy,
    method_outcome = "glm",
    family_outcome = "binomial"
  )

  ## MLE under misclass in age 
  ## imputation based on multinom
  dd <- nnet::multinom(age ~ age_m + ethnic_m, data = S_A_err_valid_sample, trace = FALSE)
  probs <- predict(dd, newdata = S_A_err, type = "probs")

  
  optim(par = rep(0, 4), 
      fn = log_reg_misclass, 
      y = S_A_err$NEP, 
      x = model.matrix(~ethnic, data = S_A_err), 
      probs = probs,
      m = matrix(c(0, 1, 0, 0, 0, 1), nrow = 3),
      method = "BFGS") -> ml_res
  
  Xs <- model.matrix(~ethnic + age, data = S_B)

  preds <- plogis(Xs %*% ml_res$par)
  
  S_B_svy <- update(S_B_svy, NEP_mle = preds)
  
  res_mle <- svymean(~NEP_mle, design = S_B_svy)
  res_mle_ci <- confint(res_mle)
  
  results[[r]] <- data.frame(
    nep_srs = est_sb[1],
    nep_naive = est_sa_naive[1],
    nep_mi = est_sa_mi$output$mean[1],
    nep_err = est_sa_mi_errors$output$mean[1],
    nep_li = res[1],
    nep_qu = res[2],
    nep_ll = res[3],
    nep_imp = est_sa_mi_imp$output$mean[1],
    nep_mle = res_mle[1],
    cr_cor = est_sa_mi$confidence_interval[1, 1] < mean(pop_data$NEP) & est_sa_mi$confidence_interval[1, 2] > mean(pop_data$NEP), 
    cr_err = est_sa_mi_errors$confidence_interval[1, 1] < mean(pop_data$NEP) & est_sa_mi_errors$confidence_interval[1, 2] > mean(pop_data$NEP), 
    cr_li = res_ci[1, 1] < mean(pop_data$NEP) & res_ci[1, 2] > mean(pop_data$NEP),
    cr_qu = res_ci[2, 1] < mean(pop_data$NEP) & res_ci[2, 2] > mean(pop_data$NEP),
    cr_ll = res_ci[3, 1] < mean(pop_data$NEP) & res_ci[3, 2] > mean(pop_data$NEP),
    cr_imp = est_sa_mi_imp$confidence_interval[1, 1] < mean(pop_data$NEP) & est_sa_mi_imp$confidence_interval[1, 2] > mean(pop_data$NEP),
    cr_mle = res_mle_ci[1, 1] < mean(pop_data$NEP) & res_mle_ci[1, 2] > mean(pop_data$NEP)
  )
}

results_df <- rbindlist(results, idcol = "rep")
```

Boxplot of point estimates from simulations

```{r fig-results}
results_df[,1:10] |>
  melt(id.vars = 1) |>
  ggplot(data = _, aes(x = variable, y= value)) +
  geom_boxplot() +
  geom_jitter(width = 0.1, alpha = 0.5) +
  stat_summary(fun = mean, color = "blue", geom = "point", size = 3) +
  geom_hline(yintercept = mean(pop_data$NEP), col = "red") +
  labs(x = "Estimators", y = "Point estimates") 
```
Coverage rate

```{r}
colMeans(results_df[,11:17]) |> kable()
```
Results of the simulation

```{r}
results_df[,1:10] |>
  melt(id.vars = 1) |>
  {\(x) x[, .(bias = mean(value) - mean(pop_data$NEP),
              sd = sd(value),
              rmse = sqrt( (mean(value) - mean(pop_data$NEP))^2 + var(value))), variable]}() |>
  transform(bias = bias*100, sd=sd*100, rmse=rmse*100) |>
  kable()
```

